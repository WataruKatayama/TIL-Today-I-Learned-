# 最初の環境構築  
### WebサーバとAPIサーバの二つの部分に分け、サーバはそれぞれ、Amazon VPC内に構築したPublic Subnetの中に、Amazon EC2を用いて構築する  
  
※Webサーバ：ブラウザ上で実行されるWebアプリケーションで、必要な情報をAPIサーバから取得し、ユーザーに表示させる  
　APIサーバ：Webサーバからのリクエストに基づき適切な処理を行い、レスポンスを返す  

  
## VPCの作成  
● 新規VPCとして、reservation-vpcを作成する  
● CIDRの指定は10.0.0.0/21とする  
  
 <手順>  
 1.ダッシュボードから「お使いのVPC」を選択し、右上「VPCを作成」を選択  
 2.作成するリソース「VPCのみ」、名前タグ、オプション「reservation-vpc」、IPv4CIDRブロック「IPv4CIDRの手動入力」、IPv4CIDR「10.0.0.0/21」、テナンシー「デフォルト」、タグ「Name」「reservation-vpc」に設定し「VPCを作成」をクリック  
 3.正常にVPCが作成されれば完了  

 ## web-subnet-01を作成  
● Webサーバを配置するためのサブネットとして、web-subnet-01を作成する  
● CIDRの指定は10.0.0.0/24とする  
● ルートテーブルとしてweb-routetableを作成し、web-subnet-01に関連付けする  
  
<手順 サブネットの作成>  
1.ダッシュボードから「サブネット」を選択し、右上「サブネットを作成」を選択  
2.VPCID「reservation-vpc（作成したVPC名）」、サブネット名「web-subnet-01」、アベイラビリティゾーン「ap-nothest-1a」、IPv4 VPC CIDRブロック「そのまま」、IPv4サブネットCIDRブロック「10.0.0.0/24」、タグ「Name」「web-subnet-01」に設定し「サブネットを作成」をクリック  
3.正常にweb-subnet-01が作成されれば完了  
  
<手順　ルートテーブルの作成 + 関連付け>  
1.ダッシュボードから「ルートテーブル」を選択し、右上「ルートテーブルを作成」を選択  
2.名前オプション「web-routetable」、VPC「reservation-vpc（作成したVPC名）」、タグ「Name」「web-routetable」に設定し「ルートテーブルを作成」をクリック  
3.正常にweb-routetableが作成されれば作成完了  
4.作成されたルートテーブル「web-routetable」にチェックを入れ、下にある「サブネットの関連付け」をクリック  
5.右側の「サブネットの関連付けを編集」をクリックし、「web-routetable」にチェックを入れ、「関連付けを保存」をクリック  
6.ルートテーブルの詳細画面に移動するので、「サブネットの関連付け」をクリックし、サブネットIDが表示されていれば関連付け完了  
  
 ## api-subnet-01を作成  
● APIサーバを配置するためのサブネットとして、api-subnet-01を作成する  
● CIDRの指定は10.0.1.0/24とする  
● ルートテーブルとしてapi-routetableを作成し、api-subnet-01に関連付けする  
  
<手順 サブネットの作成>  
1.ダッシュボードから「サブネット」を選択し、右上「サブネットを作成」を選択  
2.VPCID「reservation-vpc（作成したVPC名）」、サブネット名「api-subnet-01」、アベイラビリティゾーン「ap-nothest-1a」、IPv4 VPC CIDRブロック「そのまま」、IPv4サブネットCIDRブロック「10.0.1.0/24」、タグ「Name」「api-subnet-01」に設定し「サブネットを作成」をクリック  
3.正常にweb-subnet-01が作成されれば完了  
  
<手順　ルートテーブルの作成 + 関連付け>  
1.ダッシュボードから「ルートテーブル」を選択し、右上「ルートテーブルを作成」を選択  
2.名前オプション「api-routetable」、VPC「reservation-vpc（作成したVPC名）」、タグ「Name」「api-routetable」に設定し「ルートテーブルを作成」をクリック  
3.正常にapi-routetableが作成されれば作成完了  
4.作成されたルートテーブル「api-routetable」にチェックを入れ、下にある「サブネットの関連付け」をクリック  
5.右側の「サブネットの関連付けを編集」をクリックし、「api-routetable」にチェックを入れ、「関連付けを保存」をクリック  
6.ルートテーブルの詳細画面に移動するので、「サブネットの関連付け」をクリックし、サブネットIDが表示されていれば関連付け完了  
  
## インターネットゲートウェイの作成  
● reservation-igという名前のインターネットゲートウェイを作成し web-routetableおよびapi-routetableに設定する  
  
<手順　インターネットゲートウェイ>  
1.ダッシュボードから「インターネットゲートウェイ」を選択し、右上「インターネットゲートウェイの作成」を選択  
2.名前タグ「 reservation-ig」、タグオプション「Name」「reservation-ig」に設定し「インターネットゲートウェイの作成」クリック  
3.詳細画面に移動するので画面右の「アクション」から「VPCにアタッチ」を選択する  
　→状態が「Detached(どこのVPCにも設定されていないという意味)」なのでアタッチの設定もセットで必要  
4.使用可能なVPCに「reservation-vpc（作成したVPC名）」を選択し「インターネットゲートウェイのアタッチ」をクリック  
5.詳細画面に移り、VPCのIDが表示され、状態が「Atached」になっていれば設定完了  
  
<手順　インターネットゲートウェイとルートテーブルのルーティング>  
1.ダッシュボードから「ルートテーブル」を選択し、Webルートテーブルにチェックを入れる  
2.下にある「ルート」をクリックし、右にある「ルートを編集」をクリック  
3.「ルートを追加」をクリックし「0.0.0.0/0(すべての通信)」、「インターネットゲートウェイ」、igw-「reservation-ig(インターネットゲートウェイの名前)」に設定し、「変更を保存」をクリック  
4.詳細画面に移り、0.0.0.0/0のルートテーブルが追加されていれば設定完了  
　→これでルートテーブルとインターネットゲートウェイとでデータが行き来できるようになる  
5.APIルートテーブルも同じ手順でルートテーブル0.0.0.0/0を追加する  
  
## APIサーバの構築  
● api-subnet-01の中にEC2インスタンスを一つ作成し、api-server-01とする  
● EC2インスタンス作成時のAMIは、Amazon Linux 2023を選択する  
● APIサーバおよびWebサーバに対するインバウンド通信は、「すべての HTTP通信」のみとする  
● ただし、メンテナンスのためのssh接続が必要な場合は、許可しても構わない  
  
<手順　EC2インスタンスの準備（SSH接続ができる状態まで）>  
1.EC2インスタンスの画面まで移り、ダッシュボードから「インスタンス」を選択し、画面右の「インスタンスの起動」をクリックする  
2.名前とタグ「api-server-01」、クイックスタートAMI「Amazon Linux 2023」、アーキテクチャ「64ビット（x86）」、インスタンスタイプ「t2.maicro」、キーペアは新規作成でキーペア名「api-ec2-key」キーペアのタイプ「RSA」キー形式「.pem」でキーペアを作成する  
→キーペアと同じ名前のキーファイルがダウンロードされるのでとりあえずデスクトップにファイルを保存しておく  
3.ネットワーク設定の「編集」をクリックし、VPC-必須「reservation-vpc」、サブネット「api-subnet-01」、パブリックIPの自動割り当て「無効化（有効化にすると自動でIPアドレスを割り振ってくれる）」、ファイアウォール「セキュリティグループを作成」、セキュリティグループ名「api-sg-1」、説明にも同じく「api-sg-1」に設定する  
4.インバウンドのセキュリティグループのルールは下記の通りとなる  
　「APIサーバおよびWebサーバに対するインバウンド通信は、「すべての HTTP通信」のみとする」  
 　→タイプ「HTTP」、プロトコル「TCP」、ポート80、ソースタイプ「カスタム」「0.0.0.0/0」  
  
　「ただし、メンテナンスのためのssh接続が必要な場合は、許可しても構わない」  
 　→セキュリティの観点から、SSH（ポート22）は常に開けっ放しにせず、自分のIPアドレスのみ許可　←自分のIPのみに関しては課題点あり  
  　タイプ「ssh」、プロトコル「TCP」、ポート22、ソースタイプ「自分のIP」  
 5.ストレージはそのままで「インスタンスを起動」をクリック  
 6.「すべてのインスタンスを表示」をクリックしEC2のインスタンス画面へ移る  
 7.ステータスチェック画面が「2/2のチェックに合格しました」と表示されれば起動完了  
  
<手順　サーバとエラスティックIPアドレスの関連付け>  
1.EC2インスタンスの画面まで移り、ダッシュボードから「Elastic IP」を選択し、画面右の「ElasticIPアドレスを割り振る」をクリックする  
2.新規で作成されたエラスティックIPアドレスにチェックを入れ、「アクション」の「Elastic IPアドレスを関連付ける」を選択する  
3.「インスタンス」にチェックが入っていることを確認し、インスタンスの検索枠には「api-server-01」を選択する（プライベートIPアドレスは空白のままにする）  
4.右下の「関連付ける」をクリックし、エラスティックIPアドレスの詳細画面に移動したら、ダッシュボードから「インスタンス」を選択しインスタンスの一覧画面に移る  
5.パブリックIPv4アドレスにエラスティックIPアドレスが表示されていれば設定完了  
6.SSH接続を実行し、接続できるかどうか確認する  
  
## APIサーバのセッティング(あらかじめAPIサーバにSSH接続しておく)  
1.ソフトを最新の状態に更新するためにアップデート作業を行う  
```sudo yum update -y```  
2.GitHub などからAPIの**ソースコードを取得する  
```sudo yum install -y git```  
3.APIサーバを動かすために使われるプログラミング言語であるGo言語をインストールする    
```sudo yum install -y golang```  
4.インストール完了確認にGoのバージョンを確認する  
```go version```   
5.今回はGitHub上にあるAPIのソースコードを使用するため、一式をローカルにコピーする  
```git clone https://github.com/CloudTechOrg/cloudtech-reservation-api.git```  
6.サーバを再起動しても、APIサーバが自動で起動するように設定する  
　→まずはviエディターを使用し、Goで作ったアプリであるAPIサーバーを自動起動・管理するための設定ファイルを開く  
 ```sudo vi /etc/systemd/system/goserver.service```  
7.サービス起動時の設定ファイルを作成  
```[Unit]```  
```Description=Go Server```  
```[Service]```  
```WorkingDirectory=/home/ec2-user/cloudtech-reservation-api```  
```ExecStart=/usr/bin/go run main.go```  
```User=ec2-user```  
```Restart=always```  
```[Install]```  
```WantedBy=multi-user.target```  
[service内の内容確認]  
WorkingDirectory	:プログラムのあるフォルダ。プログラムを実行する際の対象ディレクトリを指定。  
ExecStart	:起動時に実行するコマンド。サービスが起動する際に実行するコマンド（Go言語で作ったアプリmain.go をそのまま実行）  
          ※ 本番環境では go build でバイナリを作ってから起動するのが一般的。ここでは簡易的に go run を使用。  
User	:誰の権限で動かすか。ここではサービスを実行するのはec2-user 
Restart	:サーバが落ちるなど異常終了したら自動で再起動させる  
  
[Install内の確認]  
WantedBy	:サーバーが通常の状態（multi-userモード）で起動したときに、このサービスも自動で起動するようにするモード  
  
8.編集した内容を再起動させる  
```sudo systemctl daemon-reload```  
9.作成した goserver.service を サーバ起動時に自動で起動させるように設定  
```sudo systemctl enable goserver.service```  
10.サービスを起動させる  
```sudo systemctl start goserver.service```  
11.Goサーバーは内部で8080ポートで動作しているので要件にもある通りHTTP（80）でアクセスさせるためNginxを使用して中継させる。まずはNginxのインストールおよび起動作業。  
```sudo yum install nginx```  
```sudo systemctl start nginx```  
```sudo systemctl enable nginx```  
12.Goサーバ(8080)をHTTP(80)にアクセスできるようにnginx.confファイルを編集  
```sudo vi /etc/nginx/nginx.conf```  
13.serverの箇所を下記に丸ごと上書きで書き換える  
```server {```  
```listen 80;```　←HTTPの標準ポート「80番」でリクエストを受け付けるという意味  
```server_name _;```　←サーバー名の指定。_（アンダースコア）はデフォルト設定（どのドメインでも対応） を意味する  
``` ```  
``` location / {```　←/ は ルートパス（＝すべてのURLパス）。つまり、どのURLにアクセスしてもこの中の設定が使われる。  
```proxy_pass http://localhost:8080;```　← ユーザーから受けたリクエストを 内部の 8080 ポート（＝Goアプリ）に転送する  
```proxy_http_version 1.1;```　←プロキシとして通信する際に HTTP/1.1 を使用する設定  
```proxy_set_header Upgrade $http_upgrade;```　←WebSocket通信などのために、元のリクエストヘッダー Upgrade をGoアプリに伝える  
```proxy_set_header Connection 'upgrade';```　←WebSocketなどの接続の「アップグレード」を明示する。上記と2行あることで、GoアプリがWebSocket対応している場合も正常動作することができる。  
``` proxy_set_header Host $host;```　←リクエスト元のホスト名（ドメイン名）をGoアプリ側に渡す設定。これによりアプリ側が「どこ経由でアクセスされたか」を知ることができる。  
```proxy_cache_bypass $http_upgrade;```　← WebSocketなどの リアルタイム通信ではキャッシュを無効にするための設定。  
``` }```  
```}```  
14.Nginxを再起動して設定を反映させる  
```sudo systemctl restart nginx```  
15.まずはGoアプリに直接アクセスして接続テスト  
```curl http://localhost:8080```  
API接続テストが成功しました が出ればOK  
16.次にNginx経由で接続テスト  
```curl http://localhost```  
同じくAPI接続テストが成功しました が出ればOK  
17.ブラウザで確認  
```http://EC2インスタンスのパブリックIPアドレス```  
ブラウザ画面にAPI接続テストが成功しました が出ればOK  
  
## Webサーバの構築  
  
